using System.Net;
using System.Text.Json;
using Battle.API.Options;
using FluentValidation;
using Grpc.Core;
using Microsoft.AspNetCore.Authorization;
using Microsoft.Extensions.Options;
using Redis.OM;
using Redis.OM.Searching;

namespace Battle.API.Features.Player;

public class PlayerService : API.Player.PlayerBase
{
    private readonly IValidator<NewPlayerRequest> _validator;
    private readonly ILogger<PlayerService> _logger;
    private readonly HttpClient _httpClient;
    private readonly KeycloakOptions _keycloakOptions;
    private readonly BattleStatsOptions _battleStatsOptions;
    private readonly IRedisCollection<Domain.Player> _playerCollection;

    public PlayerService(
        HttpClient httpClient,
        RedisConnectionProvider redisConnectionProvider,
        IValidator<NewPlayerRequest> validator,
        IOptions<BattleStatsOptions> battleStatsOptions,
        IOptions<KeycloakOptions> keycloakOptions,
        ILogger<PlayerService> logger)
    {
        _httpClient = httpClient;
        _validator = validator;
        _battleStatsOptions = battleStatsOptions.Value;
        _keycloakOptions = keycloakOptions.Value;
        _logger = logger;
        _playerCollection = redisConnectionProvider.RedisCollection<Domain.Player>();
    }

    /// <summary>
    /// Create a Player. We leverage all the responsibility to Keycloak (or our Identity Provider)
    /// We'll use the UUID generated by keycloak as a Player ID in our game as well.
    /// </summary>
    /// <param name="newPlayerRequest"></param>
    /// <param name="context"></param>
    /// <returns>A new fresh Player.</returns>
    /// <exception cref="RpcException"></exception>
    [AllowAnonymous]
    public override async Task<NewPlayerResponse> Create(NewPlayerRequest newPlayerRequest, ServerCallContext context)
    {
        if (context.GetHttpContext().User.Identity?.IsAuthenticated ?? false)
            throw new RpcException(new Status(StatusCode.AlreadyExists, "Already Authenticated."));
        
        var validationResult = await _validator.ValidateAsync(newPlayerRequest, context.CancellationToken);
        if (!validationResult.IsValid)
        {
            var errorMessages = string.Join(';', validationResult.Errors.Select(x => x.ErrorMessage));
            throw new RpcException(new Status(StatusCode.InvalidArgument, errorMessages));
        }
        
        // TODO: The user creation could be refactored to an authentication service (including what is in Authentication feature as well)
        var adminAccessToken = await GetAdminAccessTokenAsync(context.CancellationToken);
        var userId = await CreateUserInProviderAsync(newPlayerRequest, adminAccessToken, context.CancellationToken);

        var newPlayer = new Domain.Player
        {
            Id = userId,
            UserName = newPlayerRequest.Username,
            Description = newPlayerRequest.Description,
            Attack = newPlayerRequest.Attack,
            Defense = newPlayerRequest.Defense,
            HitPoints = _battleStatsOptions.BaseHitPoints + (newPlayerRequest.Defense * _battleStatsOptions.MultiplicativeHitPoints),
            Gold = _battleStatsOptions.InitialGold,
            Silver = _battleStatsOptions.InitialSilver
        };

        // TODO: Protect against transient errors with a generic general handler?
        _ = await _playerCollection.InsertAsync(newPlayer);

        _logger.LogInformation("Player {PlayerId} has been created.", newPlayer.Id);
        return PlayerMapper.ToNewPlayerResponse(newPlayer);
    }
    
    private async Task<string> GetAdminAccessTokenAsync(CancellationToken cancellationToken = default)
    {
        var request = new FormUrlEncodedContent(new Dictionary<string, string>
        {
            { "grant_type", "client_credentials" },
            { "client_id", _keycloakOptions.AdminClientId },
            { "client_secret", _keycloakOptions.AdminClientSecret }
        });

        var response = await _httpClient.PostAsync(_keycloakOptions.TokenUrl, request, cancellationToken);
        if (!response.IsSuccessStatusCode)
            LogAndThrowError(StatusCode.Unavailable, response.StatusCode, await response.Content.ReadAsStringAsync(cancellationToken));

        var json = await response.Content.ReadFromJsonAsync<JsonElement>(cancellationToken: cancellationToken);
        var accessToken = json.GetProperty("access_token").GetString();
        if (string.IsNullOrEmpty(accessToken))
            LogAndThrowError(StatusCode.Unavailable, response.StatusCode, "Access token is null or empty");

        return json.GetProperty("access_token").GetString()!;
    }
    
    private async Task<string> CreateUserInProviderAsync(NewPlayerRequest newPlayerRequest, string adminAccessToken, CancellationToken cancellationToken = default)
    {
        var userPayload = new
        {
            username = newPlayerRequest.Username,
            email = newPlayerRequest.Email,
            firstName = newPlayerRequest.Username,
            lastName = newPlayerRequest.Username,
            enabled = true,
            credentials = new[]
            {
                new
                {
                    type = "password",
                    value = newPlayerRequest.Password,
                    temporary = false
                }
            }
        };
        
        var createUserRequest = new HttpRequestMessage(HttpMethod.Post, $"{_keycloakOptions.AdminApiBaseUrl}/users")
        {
            Content = JsonContent.Create(userPayload),
            Headers = { Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", adminAccessToken) }
        };

        var response = await _httpClient.SendAsync(createUserRequest, cancellationToken);
        if (!response.IsSuccessStatusCode)
            LogAndThrowError(StatusCode.Unavailable, response.StatusCode, await response.Content.ReadAsStringAsync(cancellationToken));

        // Hacky but it's a easy way of get the new UserId. TODO: Refactor this, because if this fails, the identity is already created.
        var userId = response.Headers.Location?.Segments.Last()
                     ?? throw new RpcException(new Status(StatusCode.Unavailable, "Something went wrong."));
        
        return userId;
    }

    private void LogAndThrowError(StatusCode grpcStatusCode, HttpStatusCode statusCode, string reason)
    {
        _logger.LogError("Registration failed: {StatusCode} - {Reason}.", statusCode, reason);
        throw new RpcException(new Status(grpcStatusCode, "Something went wrong."));
    }
}